<script type="module">
        import { GoogleGenerativeAI } from "https://esm.run/@google/generative-ai";
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

        const logArea = document.getElementById('log');
        const resultArea = document.getElementById('result');
        const apiKeyInput = document.getElementById('apiKey');
        const modelSelect = document.getElementById('modelSelect');
        const startPageInput = document.getElementById('startPage');
        const endPageInput = document.getElementById('endPage');
        const copyBtn = document.getElementById('copyBtn');
        const copyMsg = document.getElementById('copyMsg');

        apiKeyInput.value = localStorage.getItem('gemini_api_key') || "";
        modelSelect.value = localStorage.getItem('gemini_model_choice') || "gemini-2.0-flash";

        document.getElementById('saveKeyBtn').onclick = () => {
            localStorage.setItem('gemini_api_key', apiKeyInput.value);
            localStorage.setItem('gemini_model_choice', modelSelect.value);
            alert("設定を保存しました。");
        };

        copyBtn.onclick = async () => {
            if (!resultArea.value) return;
            await navigator.clipboard.writeText(resultArea.value);
            copyMsg.style.opacity = "1";
            setTimeout(() => { copyMsg.style.opacity = "0"; }, 2000);
        };

        const addLog = (msg, type = '') => {
            const div = document.createElement('div');
            if (type === 'error') div.className = 'log-error';
            if (type === 'retry') div.className = 'log-retry';
            if (type === 'success') div.className = 'log-success';
            div.innerHTML = msg;
            logArea.appendChild(div);
            logArea.scrollTop = logArea.scrollHeight;
        };

        document.getElementById('startBtn').onclick = async () => {
            const file = document.getElementById('pdfFile').files[0];
            const key = apiKeyInput.value;
            const selectedModel = modelSelect.value;
            if (!file || !key) { alert("PDFとAPIキーが必要です。"); return; }
            
            logArea.innerHTML = "";
            resultArea.value = "";

            try {
                const genAI = new GoogleGenerativeAI(key);
                const model = genAI.getGenerativeModel({ model: selectedModel });
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
                
                const actualStart = Math.max(1, parseInt(startPageInput.value) || 1);
                const actualEnd = Math.min(pdf.numPages, parseInt(endPageInput.value) || pdf.numPages);

                for (let i = actualStart; i <= actualEnd; i++) {
                    addLog(`[${i}/${actualEnd}] レイアウト解析中...`);
                    const page = await pdf.getPage(i);
                    const viewport = page.getViewport({scale: 2.5});
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;
                    await page.render({canvasContext: ctx, viewport: viewport}).promise;

                    // 1. レイアウト判定用の画像生成（ページ全体）
                    const fullPageBase64 = canvas.toDataURL('image/jpeg', 0.8).split(',')[1];
                    
                    let layoutType = "SINGLE";
                    try {
                        const layoutPrompt = "この画像は「一段組（1ページ1面）」ですか、それとも「二段組（見開き）」ですか？ 'SINGLE' または 'DOUBLE' とだけ回答してください。";
                        const layoutResult = await model.generateContent([{ inlineData: { data: fullPageBase64, mimeType: "image/jpeg" } }, layoutPrompt]);
                        layoutType = layoutResult.response.text().toUpperCase();
                    } catch (e) {
                        addLog(`  [!] レイアウト判定失敗。一段組として続行します。`, 'retry');
                    }

                    // 2. 判定結果に基づいて分割設定を決定
                    let sides = [];
                    if (layoutType.includes("DOUBLE")) {
                        addLog(`  -> 二段組として左右分割して処理します。`);
                        const mid = canvas.width / 2;
                        const margin = Math.floor(canvas.width * 0.05); 
                        sides = [
                            { name: "右側", x: mid - margin, w: canvas.width - (mid - margin) },
                            { name: "左側", x: 0, w: mid + margin }
                        ];
                    } else {
                        addLog(`  -> 一段組として全体を処理します。`);
                        sides = [
                            { name: "全体", x: 0, w: canvas.width }
                        ];
                    }

                    // 3. 各パーツ（または全体）のOCR実行
                    let pageText = `--- Page ${i} ---\n`;
                    for (const side of sides) {
                        const sCanvas = document.createElement('canvas');
                        sCanvas.width = side.w; sCanvas.height = canvas.height;
                        sCanvas.getContext('2d').drawImage(canvas, side.x, 0, side.w, canvas.height, 0, 0, side.w, canvas.height);
                        const base64Data = sCanvas.toDataURL('image/jpeg', 0.8).split(',')[1];
                        
                        const prompt = `指示：日本語書籍（縦書き）の超高精度テキスト化と論理構造の再構築

1. 役割
あなたは、国立国会図書館のデジタルアーカイブ化プロジェクトに従事する、世界最高峰のデータ入力エキスパートです。提示された画像（スキャンされた日本語の縦書き・見開き書籍）を読み取り、**書籍の物理的な行区切りではなく、著者が意図した論理的な文章構造として**テキスト化してください。

2. ドキュメント構造の理解
* **文章の連結（最重要）**: 書籍上の物理的な改行位置では**絶対に改行コードを入れないでください**。行末と次行の行頭は、間にスペースを入れずに連結し、一つの文として続けてください。
* **段落の扱い**: 改行を行うのは、**「段落が変わる箇所（通常、文頭が一字下がっている箇所）」**および「見出し」の前後のみとしてください。

3. 具体的な処理規則
* **文字認識**: 常用漢字、旧字体、ひらがな、カタカナ、句読点を正確に識別してください。
* **ノイズの除去**: ページ番号（ノンブル）、ヘッダー（柱）、フッターは本文の文脈を分断するため、**出力から完全に除外してください**。
* **推論による補完**: スキャンの歪みや綴じ部分の影で文字が不鮮明な場合や明らかなOCRエラーは、前後の文脈から日本語として最も自然な文字を推論して埋めてください。
* **ルビ・図表**: 本文の自然な流れを阻害しないよう、ルビや図表内の文字は読み飛ばしてください。
* **不要な空白の削除**: 文字間の不自然なスペースはすべて削除し、詰めて記述してください。

4. 出力形式
出力は純粋なtext形式とし、挨拶や解説は一切含めないでください。`;

                        let success = false;
                        let maxRetries = 3;
                        for (let attempt = 0; attempt < maxRetries; attempt++) {
                            try {
                                const result = await model.generateContent([{ inlineData: { data: base64Data, mimeType: "image/jpeg" } }, prompt]);
                                const text = result.response.text();
                                if (text) {
                                    pageText += text + "\n";
                                    success = true;
                                    break;
                                }
                            } catch (err) {
                                const msg = err.message || "";
                                if (msg.includes("429") || msg.includes("RESOURCE_EXHAUSTED") || msg.includes("503")) {
                                    const waitSec = 30 * (attempt + 1);
                                    addLog(`  [!] ${side.name}: 制限中... ${waitSec}秒待機 (${attempt + 1}/${maxRetries})`, 'retry');
                                    await new Promise(r => setTimeout(r, waitSec * 1000));
                                } else {
                                    addLog(`  [x] ${side.name}でエラー: ${msg.substring(0, 50)}`, 'error');
                                    break;
                                }
                            }
                        }
                        // API負荷軽減のための微小な待機
                        await new Promise(r => setTimeout(r, 800));
                    }
                    resultArea.value += pageText + "\n";
                    resultArea.scrollTop = resultArea.scrollHeight;
                    addLog(`[${i}/${actualEnd}] 完了`, 'success');
                }
                addLog("すべての処理が完了しました。", 'success');
            } catch (err) { addLog("重大なエラー: " + err.message, 'error'); }
        };
    </script>
